# Novi·挚友 — Java 项目结构与整体设计思路

> 本文档给出：项目目录结构、模块划分、关键类/接口示例（Java）、扩展点与可维护性/可扩展性设计注意事项，以及测试、部署与运维建议。

------

## 目标

Novi·挚友 是一个可扩展、易维护的**可定制 AI 伙伴平台**，支持：

- 调用多家 AI 厂商的 API（通过适配器/驱动模式插拔）
- 本地封装与管理提示词（Prompt 管理、版本、变量替换、模板）
- 使用数据库记录用户信息、对话与长期记忆（可扩展到向量数据库）
- 可插入自定义技能/插件、事件总线和策略
- 关注安全（API Key 管理）、可观测性与可扩展性

------

## 架构总览（建议）

采用 **分层 + 六边形/端口&适配器（Hexagonal）** 架构：

- **api-adapters/** — AI 厂商的适配器实现（OpenAI、Anthropic、Azure 等）
- **core/** — 业务核心（Prompt 管理、会话、记忆、路由）
- **persistence/** — JPA 实体、Repository（可替换为其他 DB 实现）
- **web/** — REST / WebSocket 接口（与前端/客户端通信）
- **plugins/** — 第三方技能插件目录（可热加载）
- **infrastructure/** — 消息队列、缓存、向量 DB、监控、密钥管理等
- **cli/ops/** — 部署与运维脚本

## 建议的项目目录（Maven 多模块或 Gradle 多项目）

```
novi-friend/                      # root
├─ pom.xml / build.gradle
├─ novi-core/                      # core: domain & services
│  ├─ src/main/java/.../core
│  └─ src/test
├─ novi-ai-adapters/               # 各厂商适配器（实现 AIClient 接口）
│  ├─ openai-adapter/
│  └─ anthopic-adapter/
├─ novi-persistence/                # entities, repositories, migrations
├─ novi-web/                        # spring-boot app: controllers, websocket
├─ novi-plugins/                    # 插件开发包示例
├─ novi-infra/                      # cache, messaging, vector-db clients
├─ docs/
└─ infra/                          # k8s / docker / terraform
```

------

## 主要模块职责

- **Core**：Domain models（Conversation、Message、User、Memory）、业务服务（ConversationService、PromptService、MemoryService）、接口定义（AIClient、PromptRenderer）
- **AI Adapters**：实现 `AIClient` 接口，负责与外部厂商沟通、请求/响应映射、限流/重试策略封装
- **Persistence**：使用 Spring Data JPA（或 MyBatis），将 Domain 持久化。对向量索引部分预留接口（VectorStore）
- **Web（API）**：对外提供 REST + WebSocket，处理认证/鉴权，调用 Core 服务
- **Plugins**：定义能力边界和能力契约（能力：天气、日历、查询知识库），插件通过事件/命令调用
- **Infra**：缓存（Redis）、队列（Kafka/RabbitMQ）、向量数据库（Milvus/Weaviate/PGVector）、密钥管理（Vault 或 KMS）

------

## 关键设计与扩展点（要点）

1. **接口优先（契约先行）**：核心模块只依赖接口（`AIClient`、`MemoryRepository`、`VectorStore`），具体实现放在 adapters/infra。
2. **提示词管理**：版本化的 Template 存储（可加标签、变量），支持回滚与 A/B 测试。
3. **记忆分层**：短期会话（Conversation/Message）与长期记忆（Memory，按向量/关键字索引），支持 TTL 与摘要。
4. **并发与限流**：在 AIClient 层实现请求限流与熔断、重试策略。
5. **可插拔的技能**：插件通过事件总线（或 Command pattern）订阅消息，返回结构化结果。
6. **扩展到向量数据库**：为 Embedding 和检索预留 `VectorStore` 接口，可 swap 实现。
7. **可观测性**：集成 metrics（Prometheus）、分布式 tracing（OpenTelemetry）、丰富日志（结构化日志）
8. **安全与配置管理**：私钥/API Key 存 Vault，敏感字段加密，日志不含明文 key

------

## 数据模型（简版）

- `User`：id, name, profile, settings
- `Conversation`：id, user_id, created_at, updated_at, metadata
- `Message`：id, conversation_id, role (user/assistant/system/plugin), content, tokens, created_at
- `Memory`：id, user_id, type (fact/preference/event), content, embedding_ref, last_used

------

## 示例 Java 接口与类（关键片段）

> **注意**：以下都是示例代码，用以展示接口设计与核心业务实现思路。

### 1) AIClient（端口）

```java
package com.novi.core.ai;

import com.novi.core.model.AIResponse;
import com.novi.core.model.AIRequest;

public interface AIClient {
    /**
     * 发送请求到外部 AI 厂商
     */
    AIResponse send(AIRequest request) throws AIClientException;

    /**
     * 获取适配器名称
     */
    String getName();
}
```

### 2) OpenAI 适配器（示例）

```java
package com.novi.adapters.openai;

import com.novi.core.ai.AIClient;
import com.novi.core.model.AIRequest;
import com.novi.core.model.AIResponse;

public class OpenAIAdapter implements AIClient {
    private final String apiKey; // 注：从安全组件注入

    public OpenAIAdapter(String apiKey){ this.apiKey = apiKey; }

    @Override
    public AIResponse send(AIRequest request) {
        // 构造 HTTP 请求、处理速率限制、重试、超时
        // 将第三方返回映射为 AIResponse
        return null; // 实际实现省略
    }

    @Override
    public String getName() { return "openai"; }
}
```

### 3) Prompt 模板与渲染

```java
package com.novi.core.prompt;

import java.util.Map;

public class PromptTemplate {
    private final String id;
    private final String content; // 带占位符的模板，例如: "你是一位助手，用户姓名：{{user.name}}"
    private final String version;

    public String render(Map<String, Object> ctx) {
        // 简单的占位符替换示例，生产中建议使用更强大的模板引擎
        String rendered = content;
        for (Map.Entry<String,Object> e: ctx.entrySet()){
            rendered = rendered.replace("{{"+e.getKey()+"}}", String.valueOf(e.getValue()));
        }
        return rendered;
    }
}
```

### 4) ConversationService（业务示例）

```java
package com.novi.core.service;

import com.novi.core.ai.AIClient;
import com.novi.core.model.*;
import com.novi.core.prompt.PromptTemplate;
import com.novi.persistence.repository.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class ConversationService {
    private final AIClient aiClient;
    private final ConversationRepository conversationRepository;
    private final MessageRepository messageRepository;
    private final PromptTemplate promptTemplate;

    public ConversationService(AIClient aiClient,
                               ConversationRepository conversationRepository,
                               MessageRepository messageRepository,
                               PromptTemplate promptTemplate) {
        this.aiClient = aiClient;
        this.conversationRepository = conversationRepository;
        this.messageRepository = messageRepository;
        this.promptTemplate = promptTemplate;
    }

    @Transactional
    public AIResponse handleUserMessage(String conversationId, String userId, String userMessage){
        // 1. 存储用户消息
        // 2. 准备 prompt（历史 + template + memory）
        // 3. 调用 aiClient
        // 4. 存储 assistant message
        // 5. 返回结果
        return null; // 示例省略细节
    }
}
```

### 5) JPA 实体（User / Conversation / Message 精简示例）

```java
package com.novi.persistence.entity;

import javax.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "users")
public class UserEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String displayName;
    private String profileJson;
    private Instant createdAt;
    // getters/setters
}

@Entity
@Table(name = "conversations")
public class ConversationEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long userId;
    private Instant createdAt;
    // metadata
}

@Entity
@Table(name = "messages")
public class MessageEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long conversationId;
    private String role; // user/assistant/system/plugin
    @Lob
    private String content;
    private Instant createdAt;
}
```

------

## 扩展性实现细节（具体建议）

- **工厂 + 策略模式**：对 `AIClient` 使用工厂（`AIClientFactory`），运行时可选择不同实现。
- **Feature Flags / AB 测试**：提示词变更与策略切换使用 Feature Flags（例如 Unleash、FF4J）。
- **插件沙箱**：保障插件不可直接访问敏感数据，插件能力通过能力契约暴露。
- **缓存层**：对 Embedding/Memory 检索结果做缓存，短时缓存会话上下文。
- **分页/分段检索**：对历史消息或 long context 做 sliding window 策略，避免超过 token 限制。

------

## 部署与运维建议

- Containerize（Docker）每个服务模块；用 Kubernetes 管理扩容
- 使用 Secret Manager（Vault / KMS）安全存储厂商 API Key
- 监控：Prometheus + Grafana；Tracing：Jaeger / OTEL
- 日志：结构化 JSON，集中式收集（ELK / Loki）
- CI/CD：GitHub Actions / GitLab CI + 自动化测试 + 构建镜像　

------

## 测试建议

- 单元测试覆盖业务逻辑（Prompt 渲染、消息合并）
- 集成测试：模拟 AIClient（Mock server）
- 端到端测试：使用本地向量 DB 或内存 DB 进行检索验证
- 负载测试：验证限流、重试和队列行为

------

## 示例：Gradle / Maven 快速开始（片段）

**Maven (pom.xml) 片段**

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
</dependencies>
```

------

## 开发路线建议（迭代）

1. **MVP（2-4 周）**：实现单厂商 AIClient（例如 OpenAI）、基本会话存储、PromptTemplate、简单 REST 接口
2. **v1（1-2 月）**：多厂商适配器、记忆（短期/长期）、向量 DB 集成、WebSocket 支持
3. **v2（3-6 月）**：插件系统、并发/限流优化、可观测性与多环境支撑

------

## 总结

该设计以接口驱动、模块化、关注可替换性与安全为核心，方便未来支持更多厂商、更多技能与更复杂的记忆/检索策略。

------

> 如果你需要，我可以：
>
> - 生成一个可运行的 Maven/Gradle 多模块项目脚手架（包含示例代码文件、Dockerfile、K8s manifest）
> - 生成某个模块（例如 openai-adapter 或 conversation-service）的完整实现与单元测试
> - 或把上面的示例转换为更详细的 UML / 时序图